# module-contract
solidity learning notes

1.地址是所有合约的基础，所有的合约都会继承地址对象，也可以随时将一个地址串，得到对应的代码进行调用。当然地址代表一个普通帐户时，就没有这么多丰富的功能啦。
地址类型的成员：
属性：balance
函数：send()，call()，delegatecall()，callcode()。
2.调用一个函数f()时，我们可以直接调用f()，或者使用this.f()。但两者有一个区别。前者是通过internal的方式在调用，而后者是通过external的方式在调用。请注意，这里关于this的使用与大多数语言相背。
3.复杂类型，如数组(arrays)和数据结构(struct)在Solidity中有一个额外的属性，数据的存储位置。可选为memory和storage。


memory存储位置同我们普通程序的内存一致。即分配，即使用，越过作用域即不可被访问，等待被回收。而在区块链上，由于底层实现了图灵完备，故而会有非常多的状态需要永久记录下来。比如，参与众筹的所有参与者。那么我们就要使用storage这种类型了，一旦使用这个类型，数据将永远存在。


基于程序的上下文，大多数时候这样的选择是默认的，我们可以通过指定关键字storage和memory修改它。


默认的函数参数，包括返回的参数，他们是memory。默认的局部变量是storage的1。而默认的状态变量（合约声明的公有变量）是storage。


另外还有第三个存储位置calldata。它存储的是函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。


数据位置指定非常重要，因为不同数据位置变量赋值产生的结果也不同。在memory和storage之间，以及它们和状态变量（即便从另一个状态变量）中相互赋值，总是会创建一个完全不相关的拷贝。


将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。但另一方面，将一个memory的引用类型赋值给另一个memory的引用，不会创建另一个拷贝。
4.数组有一个.length属性，表示当前的数组长度。storage的变长数组，可以通过给.length赋值调整数组长度。memory的变长数组不支持。
5.将一个struct赋值给一个局部变量（默认是storage类型），实际是拷贝的引用，所以修改局部变量值时，会影响到原变量。
